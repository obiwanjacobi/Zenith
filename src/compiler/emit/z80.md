# Z80 Assembly

https://clrhome.org/table/

## Emitting Z80 instructions

- use pluggable assembly 'routines' (without RET) to implement specific constructs and sequences.
    These pluggable routines are text files that the compiler reads and can override compiler-impl.

## Instruction Optimization

https://github.com/Zeda/Z80-Optimized-Routines
https://github.com/bchiha/Ready-Z80/tree/main/05-Z80_Optimisation
http://z80-heaven.wikidot.com/optimization

### Use LDIR to init memory

By pointing the destination just after the source of LDIR, each iteration copies the value of the last. That's why you need to initialize the first location.

```asm
    XOR A           // clear A
    LD HL, start    // LDIR-src
    LD DE, start+1  // LDIR-dst
    LD BC, length   // LDIR-len
    LD (HL), A      // init first byte
    LDIR            // go
```

### Sub-Routine fall-through

```asm
    ...
    CALL lbl
    CALL lbl
lbl:
    ...
    RET
```

### JP to last sub-routine

Not this:

```asm
sub-routine:
    ...
    CALL proc
    RET
```

But this:

```asm
sub-routine:
    ...
    JP proc
```

The RET of proc will ret the sub-routine

### Convert a HEX number to String

A contains the hex value.

```asm
    ADD A, 90H
    DAA
    ADC A, 40H
    DAA
```

Or like this:

```asm
    CP 10
    CCF
    ADC A, 30H
    DAA
```

### One liners

Most of these globber the flags or the regs.

`XOR A` clear A
'OR A' check A for zero

`LD HL, mem   INC (HL)` increment value in memory
`LD (HL), 42H` store value (const) in memory
`LD BC, 1234H` is shorter/faster than loading individual regs B and C
`RRA    JR C, lbl` check if bit 0 is set
`RLA    JR C, lbl` check if bit 7 is set
`PUSH DE   POP BC` copy 16-bit values using the stack
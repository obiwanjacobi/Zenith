# Z80 Assembly

https://clrhome.org/table/

## Emitting Z80 instructions

- use pluggable assembly 'routines' (without RET) to implement specific constructs and sequences.
    These pluggable routines are text files that the compiler reads and can override compiler-impl.

| Pattern | Action | Description |
| -- | -- | -- |
| `LD r, r` (`r`=`r`) | Delete | |
| `LD {RR}, 1` `ADD HL, RR` | Replace with `INC  HL` | |

## Instruction Optimization

https://github.com/Zeda/Z80-Optimized-Routines
https://github.com/bchiha/Ready-Z80/tree/main/05-Z80_Optimisation
http://z80-heaven.wikidot.com/optimization
https://tutorials.eeems.ca/Z80ASM/index.htm

### Use LDIR to init memory

By pointing the destination just after the source of LDIR, each iteration copies the value of the last. That's why you need to initialize the first location.

```asm
    XOR A           // clear A
    LD HL, start    // LDIR-src
    LD DE, start+1  // LDIR-dst
    LD BC, length   // LDIR-len
    LD (HL), A      // init first byte
    LDIR            // go
```

### (Mis)Use the SP as a fast data reader/writer

```asm
di // no interrupts while SP is pointing somewhere else
ld ix, 0
add ix, sp

ld hl, <addr>

loop:
    // cannot use any instructions that use the 'normal' stack
    // NO: call, ret, rst etc (push/pop other than for moving data)
    // * actually you can for write, but the return addresses etc will be placed
    // in the data-buffer.

    pop de  // reads data (forwards)
    ld (hl), e
    inc hl
    ld (hl), d

    // -or-

    ld e, (hl)
    inc hl
    ld d, (hl)
    push de // writes data (backwards)

    //exit condition
    jr nz, loop

// restore original sp
ld sp, ix
ei
```

### Sub-Routine fall-through

```asm
    ...
    CALL lbl
    CALL lbl
lbl:
    ...
    RET
```

### JP to last sub-routine

Not this:

```asm
sub-routine:
    ...
    CALL proc
    RET
```

But this:

```asm
sub-routine:
    ...
    JP proc
```

The RET of proc will ret the sub-routine

### Misuse RET with many jumps to same address

```asm
    ld hl, <addr>
    push hl

case1:
    ...
    ret

case2:
    ...
    ret
```

Requires one byte (RET) for each jump instead of 2 (JR) or 3 (JP)

### Convert a HEX number to String

A contains the hex value.

```asm
    ADD A, 90H
    DAA
    ADC A, 40H
    DAA
```

Or like this:

```asm
    CP 10
    CCF
    ADC A, 30H
    DAA
```

### One liners

Most of these globber the flags or the regs.

`XOR A` clear A
'OR A' check A for zero

`LD HL, mem   INC (HL)` increment value in memory
`LD (HL), 42H` store value (const) in memory
`LD BC, 1234H` is shorter/faster than loading individual regs B and C
`RRA    JR C, lbl` check if bit 0 is set
`RLA    JR C, lbl` check if bit 7 is set
`PUSH DE   POP BC` copy 16-bit values using the stack

### Math

Multiplication: shifted-add

```txt
      1110
+--   1101  x
| -----------
1     1110
0    0000     if bit is 0, then all 0
1   1110
1  1110     +
  -----------
  10110110
```

Not sure if this will be faster than repeated add?

```txt
multiply: (a, b)
  result = 0
  while b > 0
    if (b & 1) == 1
      result += a
    a <<= 1
    b >>= 1
  ret result
```
